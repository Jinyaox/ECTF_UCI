# #!/usr/bin/python3 -u

# # @file pair_tool
# # @author Kenta, Yiran Wang
# # @brief host tool for pairing a new key fob
# # @date 2023

# import json
# import socket
# import argparse

# from encryption import Encrypt, nonce
# from Crypto.Hash import SHA256

# # store hashed pair pin in json file


# # @brief Function to send commands to pair
# # a new fob.
# # @param unpairmed_fob_bridge, bridged serial connection to unpairmed fob
# # @param pairmed_fob_bridge, bridged serial connection to pairmed fob
# # @param pair_pin, pin used to pair a new fob
# def pair(unpaired_fob_bridge, paired_fob_bridge, pair_pin):

#     encryptor = Encrypt()

#     # Connect to both sockets for serial
#     unpaired_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#     unpaired_sock.connect(("ectf-net", int(unpaired_fob_bridge)))

#     paired_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#     paired_sock.connect(("ectf-net", int(paired_fob_bridge)))

#     # Send pair commands to both fobs
#     unpaired_sock.send(b"pair\n")
#     paired_sock.send(b"pair\n")

#     # Send pin to the paired fob
#     encrypted_pair_pin = encryptor.encrypt(pair_pin)
#     pair_pin_bytes = encrypted_pair_pin + str.encode("\n")
#     paired_sock.send(pair_pin_bytes)

#     # Set timeout for if pairing fails
#     unpaired_sock.settimeout(5)
    
#     # Try to receive data - if failed, pairing failed
#     try:
#         pair_success = unpaired_sock.recv(16)

#         while len(pair_success) != 16:
#             pair_success += unpaired_sock.recv(16 - len(pair_success))

#         plain_text = encryptor.decrypt(pair_success).decode()
#         received_nonce = plain_text[-4:]
#         with open('nonce.json', 'r') as n:
#             nonce = json.load()
#         if (received_nonce == nonce):
#             encryptor.update_nonce()
#             print("Paired")

#     except socket.timeout:
#         print("Failed to pair fob")

#     return 0


# # @brief Main function
# #
# # Main function handles parsing arguments and passing them to pair
# # function.
# def main():
#     parser = argparse.ArgumentParser()
#     parser.add_argument(
#         "--unpaired-fob-bridge",
#         help="Bridge for the unpaired fob",
#         type=int,
#         required=True,
#     )
#     parser.add_argument(
#         "--paired-fob-bridge",
#         help="Bridge for the paired fob",
#         type=int,
#         required=True,
#     )
#     parser.add_argument(
#         "--pair-pin", help="Program PIN", type=str, required=True,
#     )

#     args = parser.parse_args()

#     # check if pair pin is valid
#     hash = SHA256.new()
#     hash.update(args.pair_pin)

#     with open('../secret/car_secrets.json', 'r') as f:
#         pin_dict = json.loads()

#     if (hash.digest() in pin_dict.keys()):
#         pair(args.unpaired_fob_bridge, args.paired_fob_bridge, args.pair_pin)
#     else:
#         print("Invalid pairing pin")


# if __name__ == "__main__":
#     main()
#!/usr/bin/python3 -u

# @file enable_tool
# @author Frederich Stine
# @brief host tool for enabling a feature on a fob
# @date 2023
#
# This source file is part of an example system for MITRE's 2023 Embedded
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2023 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!
#
# @copyright Copyright (c) 2023 The MITRE Corporation

import socket
import argparse


# @brief Function to send commands to enable a feature on a fob
# @param fob_bridge, bridged serial connection to fob
# @param package_name, name of the package file to read from
def enable(fob_bridge, package_name):

    # Connect fob socket to serial
    fob_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    fob_sock.connect(("ectf-net", int(fob_bridge)))

    # Send enable command to fob
    fob_sock.send(b"enable\n")

    # Open and read binary data from package file
    with open(f"/package_dir/{package_name}", "rb") as fhandle:
        message = fhandle.read()

    # Send package to fob
    fob_sock.send(message)

    # Set timeout for if enable fails
    fob_sock.settimeout(5)
    # Try to receive data - if failed, enabling failed
    try:
        enable_success = fob_sock.recv(7)
        while len(enable_success) != 7:
            enable_success += fob_sock.recv(7 - len(enable_success))

        print(enable_success)
    except socket.timeout:
        print("Failed to enable feature")

    return 0


# @brief Main function
#
# Main function handles parsing arguments and passing them to program
# function.
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--fob-bridge", help="Bridge for the fob", type=int, required=True,
    )
    parser.add_argument(
        "--package-name", help="Name of the package file", type=str, required=True,
    )

    args = parser.parse_args()

    enable(args.fob_bridge, args.package_name)


if __name__ == "__main__":
    main()

